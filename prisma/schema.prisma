// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider        = "prisma-client"
  output          = "../src/generated/prisma"
  previewFeatures = ["relationJoins"]

  runtime                = "nodejs"
  moduleFormat           = "cjs"
  generatedFileExtension = "ts"
}

datasource db {
  provider = "postgresql"
}

model User {
  id            String     @id @default(cuid())
  email         String     @unique
  emailVerified DateTime?  @map("email_verified")
  username      String?    @unique
  password      String?
  bio           String?
  profileIcon   String?    @map("profile_icon")
  role          UserRole   @default(USER)
  status        UserStatus @default(ACTIVE)
  createdAt     DateTime   @default(now()) @map("created_at")
  updatedAt     DateTime   @default(now()) @updatedAt @map("updated_at")
  deletedAt     DateTime?  @map("deleted_at")

  account            Account[]
  refreshToken       RefreshToken[]
  reference          Reference[]
  tagRelation        TagRelation[]
  prompt             Prompt[]
  apiKeys            ApiKey[]
  subscription       Subscription[]
  serverApiKeyUsages ServerApiKeyUsage[]

  @@map("users")
}

model Account {
  id                Int       @default(autoincrement())
  userId            String
  provider          Provider
  providerAccoundId String    @map("provider_accoundId")
  createdAt         DateTime  @default(now()) @map("created_at")
  updatedAt         DateTime  @default(now()) @updatedAt @map("updated_at")
  deletedAt         DateTime? @map("deleted_at")

  user User @relation(fields: [userId], references: [id])

  @@unique([provider, providerAccoundId])
  @@map("accounts")
}

model Verification {
  id        Int              @id @default(autoincrement())
  type      VerificationType
  email     String
  ip        String?
  token     String
  expiredAt DateTime         @map("expired_at")
  createdAt DateTime         @default(now()) @map("created_at")

  @@unique([type, email, token])
  @@index([expiredAt]) // 만료된 토큰 정리용
  @@map("verifications")
}

model Blacklist {
  id        Int       @id @default(autoincrement())
  ip        String
  reason    String?
  blockedAt DateTime  @default(now()) @map("blocked_at")
  expiresAt DateTime? @map("expires_at") // 자동 해제 가능

  @@index([ip])
  @@index([expiresAt])
  @@map("blacklist")
}

model RefreshToken {
  id     Int    @id @default(autoincrement())
  token  String @unique @map("token")
  userId String @map("user_id")

  ipAddress String? @map("ip_address")
  userAgent String? @map("user_agent")
  deviceId  String? @map("device_id")

  issuedAt   DateTime  @default(now()) @map("issued_at") // 발급시간
  expiredAt  DateTime  @map("expired_at")
  lastUsedAt DateTime? @map("last_used_at")
  revokedAt  DateTime? @map("revoked_at")

  user User @relation(fields: [userId], references: [id])

  // cron으로 expired 주기적으로 삭제 필요
  @@index([userId, expiredAt])
  @@index([token, revokedAt])
  @@map("refresh_tokens")
}

model Tag {
  id         Int      @id @default(autoincrement())
  slug       String   @unique
  name       String   @unique
  usageCount Int      @default(0) @map("usage_count")
  createdAt  DateTime @default(now()) @map("created_at")
  updatedAt  DateTime @default(now()) @updatedAt @map("updated_at")

  relations TagRelation[]

  @@index([slug])
  @@index([usageCount(sort: Desc), name])
  @@map("tags")
}

// YouTube 채널
model Channel {
  id        Int    @id @default(autoincrement())
  channelId String @unique @map("channel_id")

  name         String
  handle       String?
  description  String?
  link         String
  thumbnailUrl String? @map("thumbnail_url")

  regionCode      String? @map("region_code")
  defaultLanguage String? @map("default_language")

  videoCount      Int    @default(0) @map("video_count")
  viewCount       BigInt @default(0) @map("view_count")
  subscriberCount Int    @default(0) @map("subscriber_count")

  publishedAt         DateTime  @map("published_at")
  createdAt           DateTime  @default(now()) @map("created_at")
  updatedAt           DateTime  @default(now()) @updatedAt @map("updated_at")
  lastVideoUploadedAt DateTime? @map("last_video_uploaded_at")

  subscription   Subscription[]
  channelHistory ChannelHistory[]

  @@map("channels")
}

model ChannelHistory {
  id              Int      @id @default(autoincrement())
  channelId       Int      @map("channel_id")
  videoCount      Int      @default(0) @map("video_count")
  viewCount       BigInt   @default(0) @map("view_count")
  subscriberCount Int      @default(0) @map("subscriber_count")
  createdAt       DateTime @default(now()) @map("created_at")

  channel Channel @relation(fields: [channelId], references: [id])

  @@index([channelId])
  @@map("channel_histories")
}

// 사이트 북마크
model Reference {
  id          Int      @id @default(autoincrement())
  userId      String   @map("user_id") // Clerk userId
  title       String
  url         String?
  description String?
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("references")
}

// 프롬프트
model Prompt {
  id          Int      @id @default(autoincrement())
  userId      String   @map("user_id") // Clerk userId
  title       String
  prompt      String
  description String?
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("prompts")
}

// 폴리모픽 태그 관계 (중간 테이블)
model TagRelation {
  id     Int    @id @default(autoincrement())
  tagId  Int    @map("tag_id")
  userId String @map("user_id") // 태그를 붙인 유저

  // 폴리모픽 필드
  taggableType TaggableType @map("taggable_type") // "subscription" | "reference" | ...
  taggableId   Int          @map("taggable_id") // 해당 레코드의 ID

  createdAt DateTime @default(now()) @map("created_at")

  // Relations
  tag  Tag  @relation(fields: [tagId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([tagId, taggableType, taggableId]) // 중복 방지
  @@index([userId, taggableType]) // 유저별 타입별 조회
  @@index([tagId, taggableType]) // 태그별 타입별 조회
  @@index([taggableType, taggableId]) // 특정 리소스의 태그 조회
  @@map("tag_relations")
}

// 유저별 채널 구독 (Watchlist)
model Subscription {
  id        Int      @id @default(autoincrement())
  userId    String   @map("user_id") // Clerk userId
  channelId Int      @map("channel_id")
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Relations
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  channel Channel @relation(fields: [channelId], references: [id], onDelete: Cascade)

  @@unique([userId, channelId]) // 한 유저가 같은 채널을 중복 구독 불가
  @@index([userId]) // 유저별 구독 목록 조회
  @@index([channelId]) // 채널별 구독자 수 조회
  @@map("subscriptions")
}

// YouTube API 키 (통합)
model ApiKey {
  id        Int        @id @default(autoincrement())
  type      ApiKeyType
  userId    String?    @map("user_id") // USER 타입일 때만 필수
  apiKey    String     @map("api_key")
  name      String? // SERVER 타입일 때 키 이름 (예: "primary", "backup")
  usage     Int        @default(0) // 전체 사용량 (서버 키의 경우)
  isActive  Boolean    @default(true) @map("is_active")
  createdAt DateTime   @default(now()) @map("created_at")
  updatedAt DateTime   @default(now()) @updatedAt @map("updated_at")

  user   User?               @relation(fields: [userId], references: [id], onDelete: Cascade)
  usages ServerApiKeyUsage[] // 유저별 사용량 기록

  @@unique([userId, type]) // USER: userId별 하나만
  @@unique([type, name]) // SERVER: name별 하나만
  @@index([type, isActive, usage]) // 서버 키: 사용량 낮은 순으로 조회
  @@index([userId])
  @@map("api_keys")
}

// 유저별 서버 API 키 사용량 추적 (악성 유저 방지)
model ServerApiKeyUsage {
  id        Int      @id @default(autoincrement())
  userId    String   @map("user_id")
  apiKeyId  Int      @map("api_key_id")
  date      DateTime @db.Date // 날짜만 저장 (시간 제외)
  usage     Int      @default(0) // 해당 날짜의 사용량
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @default(now()) @updatedAt @map("updated_at")

  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  apiKey ApiKey @relation(fields: [apiKeyId], references: [id], onDelete: Cascade)

  @@unique([userId, apiKeyId, date]) // 유저-키-날짜별 하나만
  @@index([userId, date]) // 유저별 일일 사용량 조회
  @@index([apiKeyId, date]) // 키별 일일 사용량 조회
  @@map("server_api_key_usages")
}

enum VerificationType {
  EMAIL_VERIFICATION // 회원가입 이메일 인증
  PASSWORD_RESET // 비밀번호 재설정
  EMAIL_CHANGE // 이메일 변경
  TWO_FACTOR // 2FA 코드
}

enum UserStatus {
  PENDING // 대기 중 (승인 대기 등)
  ACTIVE // 활성 사용자
  REJECTED // 승인이 거절된 사용자
  BLOCKED // 차단된 사용자
  DORMANT // 휴면 사용자
}

enum UserRole {
  ADMIN
  USER
}

enum TaggableType {
  REFERENCE
  CHANNEL
}

enum ApiKeyType {
  USER // 유저 API 키
  SERVER // 관리자(서버) API 키
}

enum Provider {
  GOOGLE
}
