## Prisma로 Polymorphic 관계를 효율적으로 처리하는 방법

### **핵심 원칙: N+1 문제만 피하면 충분히 빠르다**

---

### **사용중인 Table List**
- Tags
- Subscription
- Reference

### **1. 단일 엔티티 조회 (구독 1개 + 태그들)**

**2단계 쿼리:**
1. 구독 1개 조회 (include로 channel도 함께)
2. 해당 구독의 TagRelation 조회 (include로 tag도 함께)
3. JavaScript에서 합치기

**쿼리 2번이지만 괜찮은 이유:**
- 각 쿼리가 매우 빠름 (인덱스 활용)
- 네트워크 레이턴시 합쳐도 수 ms
- 코드가 명확하고 타입 안전

---

### **2. 여러 엔티티 조회 (구독 10개 + 각각의 태그들)**

**잘못된 방법 (N+1 문제):**
- 구독 10개 조회 → 쿼리 1번
- 각 구독마다 태그 조회 → 쿼리 10번
- **총 11번의 쿼리 → 느림!**

**올바른 방법 (배치 조회):**
1. 구독 10개를 한 번에 조회
2. 10개의 구독 ID를 `{ in: [1,2,3...10] }` 조건으로 TagRelation을 **한 번에** 조회
3. JavaScript에서 구독 ID별로 그룹화
4. 각 구독에 해당 태그들 매핑

**쿼리 2번만으로 해결:**
- 첫 번째: 구독 10개
- 두 번째: 태그 관계 전부 (조건: 구독 ID가 1~10 중 하나)

---

### **3. 역방향 조회 (태그로 구독 찾기)**

**예: "판타지" 태그가 붙은 내 구독들 보기**

**2단계:**
1. TagRelation에서 userId + tagId + taggableType으로 필터링 → 구독 ID 목록 획득
2. 구독 ID 목록으로 실제 구독 데이터 조회 (in 사용)

**효율적인 이유:**
- 인덱스 활용 (userId, taggableType 복합 인덱스)
- 필요한 데이터만 정확히 조회

---

### **4. 여러 타입 동시 조회 (구독 + 레퍼런스)**

**예: "판타지" 태그가 붙은 모든 것**

**3단계:**
1. TagRelation 조회 (userId + tagId)
2. taggableType별로 분리 (JavaScript filter)
3. Promise.all로 구독/레퍼런스 **병렬** 조회

**병렬 조회가 핵심:**
- 순차적으로 하면 느림
- 동시에 쿼리 날리면 빠름

---

### **5. 통계/집계 (태그별 개수)**

**Prisma groupBy 사용:**
- SQL의 GROUP BY를 Prisma로
- TagRelation을 tagId로 그룹화
- count 집계
- 별도로 Tag 정보 조회해서 매핑

---

### **성능 최적화 체크리스트:**

✅ **반드시 해야 할 것:**
- N+1 문제 피하기 (반복문 안에서 쿼리 X)
- `{ in: [...] }` 활용한 배치 조회
- 적절한 인덱스 설정

✅ **추가 최적화:**
- Promise.all로 병렬 쿼리
- 필요한 필드만 select (불필요한 데이터 제외)
- 페이지네이션 (take, skip)

❌ **하지 말아야 할 것:**
- 반복문 안에서 await prisma.xxx
- 필요없는 include
- Raw SQL 남발 (유지보수 악몽)

---

### **결론:**

Prisma 2단계 쿼리 방식으로 충분히 빠르고, 타입 안전하며, 유지보수하기 좋다. N+1만 피하고 배치 조회만 잘하면 성능 문제 없다.