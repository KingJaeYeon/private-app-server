# Project Overview

## 1. 서비스 개요

이 프로젝트는 **유튜브 채널 데이터를 수집·관리·분석하고, 태그 및 구독 정보를 기반으로 “내게 의미 있는 채널”을 발견하고 관리할 수 있게 해주는 서비스**다.

핵심 아이디어는 다음과 같다.

- 서버에서 관리하는 **YouTube API Key**(관리자용)로 여러 채널의 데이터를 주기적으로 수집한다.
- 수집한 데이터를 바탕으로 **채널 성장 히스토리(조회수 등)를 기록**하고, 이를 차트/통계에 활용한다.
- 사용자는 관심 있는 채널을 **구독**하고, **태그**를 달고, 태그/성장 추이 기준으로 **필터링·정렬**하여 채널을 탐색한다.
- 일부 기능(특히 키워드 검색, AI 생성 기능)은 **사용자 본인 API Key**를 등록해서 사용하게 한다.
- 최종 단계에서는 **유튜브 영상 → 스크립트 분석 → AI 기반 재가공/생성(쇼츠, 롱폼, 이미지 등)**까지 이어지는 파이프라인을 제공한다.

결국 이 서비스는:

1. **데이터 수집/히스토리 관리 백엔드**
2. **유저 구독·태그·추천 로직**
3. **외부 API·AI 기능과 연동되는 확장 가능한 플랫폼**

이 세 가지를 모두 아우르는, **작은 SaaS 급 백엔드**를 목표로 한다.

---

## 2. 핵심 기능 영역

서비스를 크게 나누면 다음과 같은 영역으로 구성된다.

### 2.1 채널 · 히스토리 영역

- 관리자가 가진 **YouTube API Key**로 채널 정보를 수집한다.
- `channel` 테이블에 **handle 기반**으로 유튜브 채널을 추가·관리한다.
- 스케줄러(예: 하루 1회)를 통해 각 채널의 `viewCount` 등 핵심 지표를 조회하여  
  `channel_history`에 저장한다.
- 이 히스토리 데이터를 바탕으로:
    - 채널 **성장 추이 차트**
    - **채널 간 비교**
    - 특정 기간 동안의 **성장률(growth)** 계산 등을 수행한다.

### 2.2 유저 · 구독 · 태그 영역

- 사용자는 회원가입/로그인 후 다음 기능을 사용할 수 있다.
    - 특정 채널을 **구독** (`subscription` 테이블)
    - 채널, 프롬프트, 레퍼런스 등에 **태그**를 부착 (`tag`, `tag_relation`)
- 태그 시스템:
    - 없는 태그를 추가하면 `tag` 테이블에 새로 생성된다.
    - 태그를 사용할 때마다 **사용 횟수(usage_count)**가 증가한다.
    - 실제 연결(채널/프롬프트/레퍼런스 등)은 `tag_relation`에 기록된다.
- 이 구조를 활용해:
    - “내가 구독한 채널 중 **특정 태그 조합**을 가진 채널만 보기”
    - 태그 사용량 기반으로 **다른 사람들이 많이 쓰는 태그/채널 추천** 같은 기능이 가능해진다.

### 2.3 키워드 검색 · 사용자 API Key · 할당량 관리

- **키워드 검색 기능**은 유튜브 API 쿼터 소모가 크기 때문에,
    - 각 사용자가 본인의 **YouTube API Key**를 등록해야 사용 가능하다.
- 사용자 API 키(`user_api_key`)를 저장하고,
    - 어떤 유저가 어떤 키로,
    - 어떤 엔드포인트를,
    - 어느 정도 쿼터를 소모했는지 `api_usage` 등에 기록한다.
- 이를 기반으로:
    - **일일 할당량(쿼터)** 관리
    - 과도한 사용 제어
    - 쿼터 초과 시 에러 처리/알림 등을 구현할 수 있다.

### 2.4 레퍼런스(Reference) · 프롬프트(Prompt) 영역

- `reference`:
    - 유튜브 영상, 웹 페이지, 기타 리소스를 **세밀하게 북마크**하는 도메인.
    - 제목, 링크, 메모 등과 함께 저장되며, 태그를 붙여 분류할 수 있다.
- `prompt`:
    - AI에게 사용할 **프롬프트 문구를 저장**하는 도메인.
    - 프롬프트 내용, 용도, 카테고리, 태그 등을 함께 관리한다.
- 이 둘 역시 `tag_relation`을 통해 태그와 연결되며,
    - 나중에 “이 태그를 쓰는 프롬프트/레퍼런스/채널” 같은 교차 추천도 가능해진다.

### 2.5 AI · 생성형 파이프라인 · SSE

- 후반 단계에서 추가되는 기능:
    - 유튜브 영상에서 **대본(스크립트) 추출**
    - 스크립트를 분석해 **등장인물/역할/톤** 정의
    - 등장인물에 맞는 **생성형 이미지 생성**
    - 스크립트를 변형하거나 리라이트해서
        - 쇼츠용 짧은 스크립트
        - 시니어 타깃 오디오/롱폼 스크립트 등으로 재가공
    - 챕터별 대표 장면을 뽑아서, 등장인물 일관성을 유지하며 이미지 생성
- 이 과정은 한 번에 끝나지 않는 **긴 작업(잡)**이 되기 때문에:
    - `ai_job`/`generation_job` 등의 Job 테이블에서 상태를 관리하고,
    - SSE(Server-Sent Events)를 활용해 **진행 상황을 실시간 스트리밍**한다.
- 이 영역은 **가장 나중에 구현할 단계**로,  
  앞선 데이터/도메인 구조가 단단할수록 더 강력해진다.

### 2.6 게스트(비로그인) · Public 영역

- 로그인하지 않은 사용자(게스트)는 **Public 엔드포인트**만 이용할 수 있다.
- Public에서는:
    - 최신 채널 10개 목록
    - 각 채널의 요약 정보/기본 통계
      를 “맛보기” 형태로 제공한다.
- 이를 통해:
    - 회원가입 전에도 서비스의 **가치와 분위기**를 체험하게 하고,
    - 크롤링/스크래핑/디도스 등 위험을 피하면서도 **적당한 수준의 정보 공개**를 유지한다.

---

## 3. 도메인 인벤토리

이 프로젝트에서 다루게 될 도메인들을 큰 범주별로 정리하면 다음과 같다.

### 3.1 인증 · 유저 관리

- **Auth / User**
    - 사용자 계정, 로그인/로그아웃, JWT 토큰, 리프레시 토큰, 이메일 인증 등
    - 권한/인가와 연동되어 각 도메인의 접근을 제어한다.

### 3.2 채널 · 히스토리 · 구독

- **Channel**
    - 유튜브 채널 메타데이터를 저장.
    - 서버 관리자가 가진 API Key로 handle 기반 추가 가능.
    - 사용자가 직접 원하는 채널을 추가할 수도 있다.
- **ChannelHistory**
    - 각 채널의 시점별 지표(viewCount 등)를 저장.
    - 스케줄러 배치가 하루 1회 이상 실행되어 누적 데이터를 만든다.
- **Subscription**
    - 사용자가 어떤 채널을 구독 중인지 관리.
    - `user_id + channel_id` 유니크 제약.
    - 나중에 “내 구독 채널 필터/추천”의 기반이 된다.

### 3.3 태그 · 태그 관계

- **Tag**
    - 태그 이름, 슬러그, 사용 횟수(usage_count) 등을 저장.
    - 새로운 태그를 만들면 자동으로 추가된다.
- **TagRelation**
    - 폴리모픽 관계 테이블.
    - `taggable_type`(채널/프롬프트/레퍼런스 등), `taggable_id`, `tag_id`, (옵션) `user_id` 등을 가진다.
    - N+1 방지를 위해 항상 IN 조건/배치 쿼리 중심으로 사용한다.
- 태그/관계를 분리한 이유:
    - **여러 도메인(채널, 레퍼런스, 프롬프트 등)에 태그를 재사용하기 위해**
    - 태그 사용 횟수/관계를 기반으로 **추천 시스템을 확장하기 위해**

### 3.4 API Key · 사용량 · 키워드 검색

- **AdminApiKey**
    - 서버에서 사용하는 YouTube API Key.
    - 채널/히스토리 수집 등 백그라운드 작업용.
- **UserApiKey**
    - 사용자가 등록한 외부 API Key (주로 YouTube, 나중엔 OpenAI/이미지 API 등).
    - 개인별 쿼터를 분리하기 위해 사용한다.
- **ApiUsage / Quota**
    - 어떤 유저가, 어떤 키로, 어떤 엔드포인트를 얼마나 호출했는지 기록.
    - 일일/월간 할당량, 쿼터 초과 처리에 사용.
- **KeywordSearch / SearchJob (추상 개념)**
    - 키워드 기반 유튜브 검색을 위한 로직/Job.
    - UserApiKey와 연결되어 사용량을 소모하고, 결과를 반환하거나 저장한다.

### 3.5 레퍼런스 · 프롬프트

- **Reference**
    - 유튜브 영상, 아티클, 웹 페이지 등을 북마크/레퍼런스로 관리.
    - 태그를 통해 분류·검색 가능.
- **Prompt**
    - AI 프롬프트(질문/지시문)를 저장.
    - 태그, 카테고리, 메모 등과 함께 관리.
- 두 도메인은:
    - 나중에 AI 기능과 자연스럽게 연결돼,
    - “이 프롬프트 + 이 레퍼런스 + 이 채널 조합으로 새로운 콘텐츠를 만들어라” 같은 흐름을 만들 수 있다.

### 3.6 추천 · 인기 채널 · 분석

- **Recommendation / PopularChannel (개념/도메인)**  
  아직 구체적인 테이블이 정해진 것은 아니지만, 다음 역할을 맡게 된다.
    - 내 구독 채널 중에서,
    - 태그/성장률/조회수 등을 조합해,
    - “지금 떠오르는 인기 채널”, “비슷한 채널 추천” 등을 계산.
- 구현 방식:
    - 별도 테이블을 둘 수도 있고,
    - `channel_history` + `subscription` + `tag_relation` 조인을 통해
      실시간/반실시간으로 계산할 수도 있다.

### 3.7 AI Job · SSE 스트리밍

- **AIJob / GenerationJob**
    - 긴 시간이 걸리는 생성형 작업을 관리하는 Job 도메인.
    - 상태(status), 진행률(progress), 결과(result) 등을 가진다.
- **SSE Stream**
    - Job 진행 상태를 클라이언트에 실시간으로 전달하는 스트리밍 채널.
    - 예: `GET /ai/jobs/:id/stream`

---

## 4. 1차 목표(MVP) 후보 요약

전체 그림은 크지만, 현실적인 1차 완성선은 다음과 같이 잡을 수 있다.

1. **Channel + ChannelHistory + Public API**
    - 채널을 등록하고,
    - 스케줄러로 히스토리를 쌓고,
    - 게스트에게 최신 채널 10개 + 상세 정보를 공개.

2. **User/Auth + Subscription**
    - 로그인/회원 시스템.
    - 사용자가 채널을 구독/해제하고, 내 구독 목록을 볼 수 있음.

3. **Tag + TagRelation (우선 채널에만 적용)**
    - 채널에 태그를 달고,
    - 태그를 기준으로 구독 채널 목록을 필터링할 수 있는 기반.

여기까지가 완성되면,  
**“채널을 모으고 → 기록하고 → 구독하고 → 태그로 관리하는 서비스”**로서 이미 동작하는 상태가 된다.

그 이후에:

- 키워드 검색 + UserApiKey + Usage
- Reference/Prompt
- AI/Job/SSE

를 차례대로 얹어가며 서비스를 확장해 나간다.
